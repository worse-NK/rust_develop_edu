---
создал заметку: 2024-10-16
---
## [Хранение значений с помощью переменных](https://doc.rust-lang.ru/book/ch02-00-guessing-game-tutorial.html#%D0%A5%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B9-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85)

 Для создания переменной мы используем оператор `let`:

`let apples = 5;`

Эта строка создаёт новую переменную с именем `apples` и привязывает её к значению 5. В Rust переменные неизменяемы по умолчанию, то есть как только мы присвоим переменной значение, оно не изменится.  Чтобы сделать переменную изменяемой, мы добавляем `mut` перед её именем:
```rust
let apples = 5; // неизменяемая 
let mut bananas = 5; // изменяемая
```

* Попытка изменить _немутабельную_ переменную:
	```rust
	fn main() {
		let x = 5;
		println!("The value of x is: {}", x);
		x = 6;
		println!("The value of x is: {}", x);
	}
	```
	Будет получено сообщение об ошибке относительно неизменяемости, как показано в этом выводе:
	```bash
	error[E0384]: cannot assign twice to immutable variable `x`
	 --> src/main.rs:4:5
	  |
	2 |     let x = 5;
	  |         - first assignment to `x`
	3 |     println!("The value of x is: {}", x);
	4 |     x = 6;
	  |     ^^^^^ cannot assign twice to immutable variable
	  |
	help: consider making this binding mutable
	  |
	2 |     let mut x = 5;
	  |         +++
	```
	
* Измение _мутабельной_ переменной:
	```rust
	fn main() {
		let mut x = 5;
		println!("The value of x is: {}", x);
		x = 6;
		println!("The value of x is: {}", x);
	}
	```
	Запустив программу, мы получим результат::
	```bash
	$ cargo run
	   Compiling variables v0.1.0 (file:///projects/variables)
	    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.30s
	     Running `target/debug/variables`
	The value of x is: 5
	The value of x is: 6
	```

### [Константы](https://doc.rust-lang.ru/book/ch03-01-variables-and-mutability.html#%D0%9A%D0%BE%D0%BD%D1%81%D1%82%D0%B0%D0%BD%D1%82%D1%8B)

Подобно неизменяемым переменным, _константы_ — это значения, которые связаны с именем и не могут изменяться, но между константами и переменными есть несколько различий.

Во-первых, нельзя использовать `mut` с константами. Константы не просто неизменяемы по умолчанию — они неизменяемы всегда. Для объявления констант используется ключевое слово `const` вместо `let`, а также тип значения _должен быть_ указан в аннотации.

Константы можно объявлять в любой области видимости, включая глобальную, благодаря этому они полезны для значений, которые нужны во многих частях кода.

Последнее отличие в том, что константы могут быть заданы только константным выражением, но не результатом вычисленного во время выполнения значения.

Вот пример объявления константы:

`const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;`

Имя константы - `THREE_HOURS_IN_SECONDS`, а её значение устанавливается как результат умножения 60 (количество секунд в минуте) на 60 (количество минут в часе) на 3 (количество часов, которые нужно посчитать в этой программе). Соглашение Rust для именования констант требует использования всех заглавных букв с подчёркиванием между словами. Компилятор может вычислять ограниченный набор операций во время компиляции, позволяющий записать это значение более понятным и простым для проверки способом, чем установка этой константы в значение 10 800. Дополнительную информацию о том, какие операции можно использовать при объявлении констант, см. в разделе [Раздел справки Rust по вычислениям констант](https://doc.rust-lang.ru/reference/const_eval.html).

### [Затенение (переменных)](https://doc.rust-lang.ru/book/ch03-01-variables-and-mutability.html#%D0%97%D0%B0%D1%82%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85)

Можно объявить новую переменную с тем же именем, как и у существующей переменной. Rustaceans говорят, что первая переменная _затеняется_ второй, то есть вторая переменная - это то, что увидит компилятор, когда вы будете использовать имя переменной. По сути, вторая переменная затеняет первую, принимая любое использование имени переменной на себя до тех пор, пока либо она сама не станет тенью, либо не закончится область видимости. Мы можем затенять переменную, используя то же имя переменной и повторяя использование ключевого слова `let` следующим образом:

```rust
fn main() {
    let x = 5;
    let x = x + 1;
    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {x}");
    }
    println!("The value of x is: {x}");
}
```

Эта программа сначала привязывает `x` к значению `5`. Затем она создаёт новую переменную `x`, повторяя `let x =`, беря исходное значение и добавляя `1`, чтобы значение `x` стало равным `6`. Затем во внутренней области видимости, созданной с помощью фигурных скобок, третий оператор `let` также затеняет `x` и создаёт новую переменную, умножая предыдущее значение на `2`, чтобы дать `x` значение `12`. Когда эта область заканчивается, внутреннее затенение заканчивается, и `x` возвращается к значению `6`. Запустив эту программу, она выведет следующее:

```bash
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
The value of x in the inner scope is: 12
The value of x is: 6

```

Затенение отличается от объявления переменной с помощью `mut`, так как мы получим ошибку компиляции, если случайно попробуем переназначить значение без использования ключевого слова `let`. Используя `let`, можно выполнить несколько превращений над значением, при этом оставляя переменную неизменяемой, после того как все эти превращения завершены.

Другой разницей между `mut` и затенением является то, что мы создаём совершенно новую переменную, когда снова используем слово `let` (ещё одну). Мы можем даже изменить тип значения, но снова использовать прежнее имя. К примеру, наша программа спрашивает пользователя, сколько пробелов он хочет разместить между некоторым текстом, запрашивая символы пробела, но мы на самом деле хотим сохранить данный ввод как число:

    let spaces = "   ";     
    let spaces = spaces.len();


## Типы данных

Каждое значение в Rust относится к определённому _типу данных_, который указывает на вид данных, что позволяет Rust знать, как работать с этими данными. Мы рассмотрим два подмножества типов данных: скалярные и составные.

Rust является _статически типизированным_ (statically typed) языком. Это означает, что он должен знать типы всех переменных во время компиляции. Обычно компилятор может предположить, какой тип используется (вывести его), основываясь на значении и на том, как мы с ним работаем. В случаях, когда может быть выведено несколько типов, необходимо добавлять аннотацию типа вручную.

### [Скалярные типы данных](https://doc.rust-lang.ru/book/ch03-02-data-types.html#%D0%A1%D0%BA%D0%B0%D0%BB%D1%8F%D1%80%D0%BD%D1%8B%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)

_Скалярный_ тип представляет собой единичное значение. В Rust есть четыре основных скалярных типа: целочисленный, числа с плавающей точкой, логический и символы. 
#### [Целочисленные типы](https://doc.rust-lang.ru/book/ch03-02-data-types.html#%D0%A6%D0%B5%D0%BB%D0%BE%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B)

Целочисленный тип (_integer_) — это число без дробной части. В таблице  3-1 показаны встроенные целочисленные типы в Rust. Мы можем использовать любой из этих вариантов для объявления типа целочисленного значения.

Таблица 3-1: целочисленные типы в Rust

| Длина                  | Со знаком | Без знака |
| ---------------------- | --------- | --------- |
| 8 бит                  | `i8`      | `u8`      |
| 16 бит                 | `i16`     | `u16`     |
| 32 бита                | `i32`     | `u32`     |
| 64 бита                | `i64`     | `u64`     |
| 128 бит                | `i128`    | `u128`    |
| архитектурно-зависимая | `isize`   | `usize`   |
Каждый вариант со знаком может хранить числа от -(2 n - 1 ) до 2 n - 1 - 1 включительно, где _n_ — количество битов, которые использует этот вариант. Таким образом, `i8` может хранить числа от -(2 7 ) до 2 7 - 1, что равно значениям от -128 до 127. Варианты без знака могут хранить числа от 0 до 2 n - 1, поэтому `u8` может хранить числа от 0 до 2 8 - 1, что равно значениям от 0 до 255.

Кроме того, типы `isize` и `usize` зависят от архитектуры компьютера, на котором выполняется программа, и обозначаются в таблице как "arch": 64 бита, если используется 64-битная архитектура, и 32 бита, если используется 32-битная архитектура.

Вы можете записывать целочисленные литералы в любой из форм, показанных в таблице 3-2. Заметьте, что числовые литералы, имеющие несколько числовых типов, допускают использование суффикса типа, например `57u8`, для обозначения типа. Числовые литералы также могут использовать `_` в качестве визуального разделителя для облегчения чтения числа, например `1_000`, который будет иметь такое же значение, как если бы было задано `1000`.

Таблица 3-2: Целочисленные литералы в Rust

| Числовой литерал   | Пример        |
| ------------------ | ------------- |
| Десятичный         | `98_222`      |
| Шестнадцатеричный  | `0xff`        |
| восьмеричный       | `0o77`        |
| Двоичный           | `0b1111_0000` |
| Байт (только `u8`) | `b'A'`        |

Как же узнать, какой тип целого числа использовать? Если вы не уверены, значения по умолчанию в Rust, как правило, подходят для начала: целочисленные типы по умолчанию `i32`. Основной случай, в котором вы должны использовать `isize` или `usize`, — это индексация какой-либо коллекции.

#### [Числа с плавающей запятой](https://doc.rust-lang.ru/book/ch03-02-data-types.html#%D0%A7%D0%B8%D1%81%D0%BB%D0%B0-%D1%81-%D0%BF%D0%BB%D0%B0%D0%B2%D0%B0%D1%8E%D1%89%D0%B5%D0%B9-%D0%B7%D0%B0%D0%BF%D1%8F%D1%82%D0%BE%D0%B9)

Также в Rust есть два примитивных типа для чисел с плавающей запятой, представляющих собой числа с десятичной точкой. Типы с плавающей точкой в Rust - это `f32` и `f64`, размер которых составляет 32 бита и 64 бита соответственно. По умолчанию используется тип `f64`, поскольку на современных процессорах он работает примерно с той же скоростью, как и `f32`, но обладает большей точностью. Все типы с плавающей запятой являются знаковыми.

```rust
fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
```

Числа с плавающей запятой представлены в соответствии со стандартом IEEE-754. Тип `f32` является плавающей запятой одинарной точности, а `f64` - двойной точности.

#### [Числовые операции](https://doc.rust-lang.ru/book/ch03-02-data-types.html#%D0%A7%D0%B8%D1%81%D0%BB%D0%BE%D0%B2%D1%8B%D0%B5-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8)

Rust поддерживает основные математические операции, привычные для всех типов чисел: сложение, вычитание, умножение, деление и остаток. Целочисленное деление обрезает значение в направлении нуля до ближайшего целого числа. Следующий код показывает, как можно использовать каждую числовую операцию в инструкции `let`:

```rust
fn main() { 
	// addition 
	let sum = 5 + 10; 
	// subtraction 
	let difference = 95.5 - 4.3; 
	// multiplication 
	let product = 4 * 30; 
	// division 
	let quotient = 56.7 / 32.2; 
	let truncated = -5 / 3; // Results in -1 
	// remainder 
	let remainder = 43 % 5; 
}
```

Каждое выражение в этих инструкциях использует математический оператор и вычисляется в одно значение, которое связывается с переменной. [Приложении B](https://doc.rust-lang.ru/book/appendix-02-operators.html) содержит список всех операторов, которые предоставляет Rust.

#### [Логический тип данных](https://doc.rust-lang.ru/book/ch03-02-data-types.html#%D0%9B%D0%BE%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9-%D1%82%D0%B8%D0%BF-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)

Как и в большинстве других языков программирования, логический тип в Rust имеет два возможных значения: `true` и `false`. Значения логических типов имеют размер в один байт. Логический тип в Rust задаётся с помощью `bool`. Например:

```rust
fn main() {     
	let t = true;  
	    
	let f: bool = false; // with explicit type annotation 
}
```

Основной способ использования логических значений - это использование условий, таких как выражение `if`.

#### [Символьный тип данных](https://doc.rust-lang.ru/book/ch03-02-data-types.html#%D0%A1%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9-%D1%82%D0%B8%D0%BF-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)

Тип `char` в Rust является самым примитивным алфавитным типом языка. Вот несколько примеров объявления значений `char`:

```rust
fn main() {     
	let c = 'z';     
	let z: char = 'ℤ'; // with explicit type annotation     
	let heart_eyed_cat = '😻'; 
}
```

Мы указываем литералы `char` с одинарными кавычками, в отличие от строковых литералов, для которых используются двойные кавычки. Тип `char` в Rust имеет размер четыре байта и представляет собой скалярное значение Unicode, а значит, может представлять собой не только ASCII. Акцентированные буквы, китайские, японские и корейские символы, эмодзи и пробелы нулевой ширины - все это допустимые значения типа `char` в Rust. Скалярные значения Unicode находятся в диапазоне от `U+0000` до `U+D7FF` и от `U+E000` до `U+10FFFF` включительно. Однако "символ" не является понятием в Unicode, поэтому ваше человеческое представление о том, что такое "символ", может не совпадать с тем, что такое `char` в Rust.




### [Составные типы данных](https://doc.rust-lang.ru/book/ch03-02-data-types.html#%D0%A1%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%BD%D1%8B%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)

_Составные типы_ могут группировать различные значения в один тип. В Rust есть два примитивных составных типа: кортежи и массивы.

#### [Кортежи](https://doc.rust-lang.ru/book/ch03-02-data-types.html#%D0%9A%D0%BE%D1%80%D1%82%D0%B5%D0%B6%D0%B8)

_Кортеж_- это универсальный способ объединения нескольких значений с различными типами в один составной тип. Кортежи имеют фиксированную длину: после объявления они не могут увеличиваться или уменьшаться в размерах.

Мы создаём кортеж, записывая список значений, разделённых запятыми, внутри круглых скобок. Каждая позиция в кортеже имеет тип, причём типы различных значений в кортеже не обязательно должны быть одинаковыми. В этом примере мы добавили необязательные аннотации типов:

```rust
fn main() { 
	let tup: (i32, f64, u8) = (500, 6.4, 1); 
}
```

Переменная `tup` связана со всем кортежем, поскольку кортеж является одним составным элементом. Чтобы получить отдельные значения из кортежа, можно использовать сопоставление с образцом для деструктуризации значения кортежа, например, так:

```rust
fn main() { 
	let tup = (500, 6.4, 1); 
	let (x, y, z) = tup; 
	println!("The value of y is: {y}");
}
```

Эта программа сначала создаёт кортеж и связывает его с переменной `tup`. Затем с помощью шаблона `let` берётся `tup` и превращается в три отдельные переменные, `x`, `y` и `z`. Это называется _деструктуризацией_, поскольку разбивает единый кортеж на три части. Наконец, программа печатает значение `y`, которое равно `6.4`.

Мы также можем получить доступ к элементу кортежа напрямую, используя точку (`.`), за которой следует индекс значения, требуемого для доступа. Например:

```rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
```

Эта программа создаёт кортеж `x`, а затем обращается к каждому элементу кортежа, используя соответствующие индексы. Как и в большинстве языков программирования, первый индекс в кортеже равен 0.

Кортеж, не имеющий значений, имеет специальное имя _единичный тип (unit)_. Это значение и соответствующий ему тип записываются как `()` и представляет собой пустое значение или пустой возвращаемый тип. Выражения неявно возвращают значение единичного типа, если не возвращают никакого другого значения.

#### [Массивы](https://doc.rust-lang.ru/book/ch03-02-data-types.html#%D0%9C%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D1%8B)

Другим способом создания коллекции из нескольких значений является массив _array_. В отличие от кортежа, каждый элемент массива должен иметь один и тот же тип. В отличие от массивов в некоторых других языках, массивы в Rust имеют фиксированную длину.

Мы записываем значения в массиве в виде списка, разделённого запятыми, внутри квадратных скобок:

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```

Массивы удобно использовать, если данные необходимо разместить в стеке, а не в куче  или если требуется, чтобы количество элементов всегда было фиксированным. Однако массив не так гибок, как вектор. _Вектор_ - это аналогичный тип коллекции, предоставляемый стандартной библиотекой, который _может_ увеличиваться или уменьшаться в размере. Если вы не уверены, что лучше использовать - массив или вектор, то, скорее всего, вам следует использовать вектор.

Тип массива записывается следующим образом: в квадратных скобках обозначается тип элементов массива, а затем, через точку с запятой, количество элементов. Например:

```rust 
fn main() {
let a: [i32; 5] = [1, 2, 3, 4, 5];
}
```

Здесь `i32` является типом каждого элемента массива. После точки с запятой указано число `5`, показывающее, что массив содержит 5 элементов.

Вы также можете инициализировать массив, содержащий одно и то же значение для каждого элемента, указав это значение вместо типа. Следом за этим так же следует точка с запятой, а затем — длина массива в квадратных скобках, как показано здесь:

```rust
fn main() {
	let a = [3; 5];
}
```

Массив в переменной `a` будет включать `5` элементов, значение которых будет равно `3`. Данная запись аналогична коду `let a = [3, 3, 3, 3, 3];`, но является более краткой.

##### [Доступ к элементам массива](https://doc.rust-lang.ru/book/ch03-02-data-types.html#%D0%94%D0%BE%D1%81%D1%82%D1%83%D0%BF-%D0%BA-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D0%BC-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0)

Массив — это единый фрагмент памяти известного фиксированного размера, который может быть размещён в стеке. Вы можете получить доступ к элементам массива с помощью rustиндексации, например:

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
```

В этом примере переменная с именем first получит значение 1, потому что это значение находится по индексу [0] в массиве. Переменная с именем second получит значение 2 по индексу [1] в массиве.

##### [Некорректный доступ к элементу массива](https://doc.rust-lang.ru/book/ch03-02-data-types.html#%D0%9D%D0%B5%D0%BA%D0%BE%D1%80%D1%80%D0%B5%D0%BA%D1%82%D0%BD%D1%8B%D0%B9-%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF-%D0%BA-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D1%83-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0)

Давайте посмотрим, что произойдёт, если попытаться получить доступ к элементу массива, находящемуся за его пределами. Допустим, вы запускаете данный код, чтобы получить от пользователя индекс массива:

```rust
use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!("Please enter an array index.");

    let mut index = String::new();

    io::stdin()
        .read_line(&mut index)
        .expect("Failed to read line");

    let index: usize = index
        .trim()
        .parse()
        .expect("Index entered was not a number");

    let element = a[index];

    println!("The value of the element at index {index} is: {element}");
}
```

* Перемення для хранения пользовательского ввода:

	    let mut index = String::new();

Этот код успешно компилируется. Если запустить этот код с помощью `cargo run` и ввести `0`, `1`, `2`, `3` или `4`, программа напечатает соответствующее значение по данному индексу в массиве. Если вместо этого ввести число за пределами массива, например, `10`, то программа выведет следующее:

```
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```


Программа столкнулась с ошибкой во _времени выполнения_ на этапе применения недопустимого значения в операции индексирования. Программа завершилась с сообщением об ошибке и не выполнила финальную инструкцию `println!`. При попытке доступа к элементу с помощью индексирования Rust проверяет, что указанный индекс меньше длины массива. Если индекс больше или равен длине, Rust паникует. Эта проверка должна происходить во время выполнения, особенно в данном случае, потому что компилятор не может знать, какое значение введёт пользователь при последующем выполнении кода.

Это пример принципов безопасности памяти Rust в действии. Во многих низкоуровневых языках такая проверка не выполняется, и когда вы указываете неправильный индекс, доступ к памяти может быть некорректным. Rust защищает вас от такого рода ошибок, немедленно закрываясь вместо того, чтобы разрешать доступ к памяти и продолжать работу.










